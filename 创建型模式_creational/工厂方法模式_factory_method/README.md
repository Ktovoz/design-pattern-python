# 工厂方法模式 (Factory Method Pattern)

## 简介
工厂方法模式是一种创建型设计模式，它提供了创建对象的接口，但允许子类决定实例化哪一个类。这种模式将类的实例化延迟到子类中进行，使得系统在不修改现有代码的情况下可以扩展。

## 模式结构
```
┌─────────────────┐     ┌─────────────────┐
│    Creator      │     │    Product      │
├─────────────────┤     ├─────────────────┤
│ +factoryMethod()│     │ +operation()    │
└────────┬────────┘     └────────┬────────┘
         │                       │
         │                       │
         ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│ ConcreteCreator │     │ ConcreteProduct │
├─────────────────┤     ├─────────────────┤
│ +factoryMethod()│     │ +operation()    │
└─────────────────┘     └─────────────────┘
```

## 核心角色
1. **抽象产品（Product）**
   - 定义产品的接口
   - 声明产品对象的基本操作

2. **具体产品（ConcreteProduct）**
   - 实现抽象产品接口
   - 定义具体的产品对象

3. **抽象创建者（Creator）**
   - 声明工厂方法
   - 可以包含产品对象的默认实现

4. **具体创建者（ConcreteCreator）**
   - 重写工厂方法
   - 返回具体产品实例

## 学习路径与难度分级

### 📚 学习建议
本项目提供了三个递进式的学习示例，建议按照以下顺序学习：

1. **入门级（1-2小时）** → 示例1：交通工具工厂
2. **进阶级（2-3小时）** → 示例2：电子产品工厂  
3. **高级级（3-5小时）** → 示例3：文档处理系统

每个示例都包含完整的代码实现和详细的注释，可以直接运行查看效果。

## 实现示例详解

### 示例1：交通工具工厂（入门级 ⭐）

**文件：** `example-1.py`  
**学习时间：** 1-2小时  
**代码行数：** ~60行

#### 🎯 学习目标
- 理解工厂方法模式的基本结构
- 掌握抽象类和抽象方法的使用
- 学会如何实现简单的工厂方法

#### 🔍 特点分析
- **简洁性**：每个产品类只有一个核心方法 `drive()`
- **直观性**：交通工具概念容易理解，适合初学者
- **标准性**：严格按照工厂方法模式的经典结构实现
- **扩展性**：可以轻松添加新的交通工具类型

#### 📋 主要类结构
```python
# 抽象产品
Vehicle (ABC)
├── drive() -> str

# 具体产品
Car, Bicycle, Motorcycle
├── 各自实现 drive() 方法

# 抽象创建者
VehicleCreator (ABC)
├── create_vehicle() -> Vehicle
├── use_vehicle() -> str

# 具体创建者
CarCreator, BicycleCreator, MotorcycleCreator
├── 各自实现 create_vehicle() 方法
```

#### 💡 适合人群
- 设计模式初学者
- 需要快速理解工厂方法模式核心概念的开发者
- 准备面试的程序员

---

### 示例2：电子产品工厂（进阶级 ⭐⭐）

**文件：** `example-2.py`  
**学习时间：** 2-3小时  
**代码行数：** ~150行

#### 🎯 学习目标
- 掌握状态管理在工厂方法模式中的应用
- 理解如何在创建者中维护产品实例
- 学习更复杂的业务逻辑实现

#### 🔍 特点分析
- **状态管理**：产品具有电池电量、开关机状态等属性
- **实例复用**：创建者维护产品实例，避免重复创建
- **业务逻辑**：包含开机、关机、电池检查等实际功能
- **类型安全**：使用类型注解提高代码可读性

#### 📋 主要类结构
```python
# 抽象产品
ElectronicProduct (ABC)
├── __init__() -> 初始化电池和状态
├── power_on() -> str
├── power_off() -> str
├── get_battery_status() -> str
├── get_device_info() -> str

# 具体产品
Smartphone, Laptop, Tablet
├── 各自的设备信息（存储、CPU、屏幕等）
├── 不同的电池消耗策略
├── 个性化的状态显示

# 抽象创建者
ElectronicCreator (ABC)
├── __init__() -> 初始化产品实例
├── get_product() -> 获取或创建产品实例
├── start_device(), stop_device(), check_battery()

# 具体创建者
SmartphoneCreator, LaptopCreator, TabletCreator
```

#### 🚀 新增功能
- **状态持久化**：设备状态在多次操作间保持
- **设备信息**：每种设备有独特的硬件配置信息
- **智能管理**：防止重复开机/关机操作
- **电池模拟**：不同设备有不同的电池消耗模式

#### 💡 适合人群
- 有一定编程基础的开发者
- 需要理解状态管理的程序员
- 想要学习实际应用场景的学习者

---

### 示例3：文档处理系统（高级级 ⭐⭐⭐）

**文件：** `example-3.py`  
**学习时间：** 3-5小时  
**代码行数：** ~250行

#### 🎯 学习目标
- 掌握复杂数据结构在工厂方法模式中的应用
- 理解元数据管理和文档处理系统的设计
- 学习高级功能的实现（搜索、导出、版本控制等）

#### 🔍 特点分析
- **复杂数据结构**：使用列表、字典、可选类型等
- **元数据管理**：自动跟踪创建时间、修改时间、版本等
- **多格式支持**：支持文本、Markdown、HTML、JSON四种格式
- **高级功能**：标签管理、内容搜索、目录生成、样式管理等
- **文档管理**：支持多文档创建和管理

#### 📋 主要类结构
```python
# 抽象产品
Document (ABC)
├── __init__(title) -> 初始化标题和元数据
├── add_content(text) -> str
├── format_content() -> str
├── export_content() -> str
├── update_metadata() -> 更新元数据
├── add_tag(tag) -> 标签管理
├── search_content(keyword) -> 内容搜索

# 具体产品
TextDocument -> 纯文本文档
├── 简单的文本处理和导出

MarkdownDocument -> Markdown文档
├── 自动目录生成 (TOC)
├── 标题层级识别
├── Markdown格式导出

HTMLDocument -> HTML文档
├── CSS样式管理
├── 完整HTML页面生成
├── 样式和内容分离

JSONDocument -> JSON文档
├── 键值对数据管理
├── JSON格式验证
├── 数据查询功能

# 抽象创建者
DocumentCreator (ABC)
├── __init__() -> 初始化文档列表
├── create_document(title) -> Document
├── create_and_edit_document() -> 批量编辑
├── export_document() -> 导出功能
├── list_documents() -> 文档管理

# 具体创建者
TextDocumentCreator, MarkdownDocumentCreator, 
HTMLDocumentCreator, JSONDocumentCreator
```

#### 🚀 高级功能特性

1. **智能元数据管理**
   - 自动版本控制
   - 字数统计
   - 时间戳跟踪

2. **多格式文档支持**
   - 文本文档：简单文本处理
   - Markdown：自动目录生成
   - HTML：CSS样式管理
   - JSON：结构化数据处理

3. **文档管理系统**
   - 多文档创建和维护
   - 文档列表查看
   - 批量操作支持

4. **高级搜索和导出**
   - 关键词搜索
   - 多种导出格式
   - 标签分类管理

#### 💡 适合人群
- 有丰富编程经验的开发者
- 需要设计复杂系统的架构师
- 想要深入理解设计模式应用的高级程序员

## 难度对比表

| 特性 | 示例1 (⭐) | 示例2 (⭐⭐) | 示例3 (⭐⭐⭐) |
|------|------------|-------------|---------------|
| **代码行数** | ~60行 | ~150行 | ~250行 |
| **类的数量** | 7个 | 10个 | 12个 |
| **抽象方法数** | 1个 | 4个 | 3个 |
| **状态管理** | 无 | 简单 | 复杂 |
| **数据结构** | 基础 | 中等 | 高级 |
| **业务逻辑** | 简单 | 中等 | 复杂 |
| **扩展功能** | 无 | 少量 | 丰富 |
| **学习时间** | 1-2小时 | 2-3小时 | 3-5小时 |

## 实践练习

### 🔰 基础练习（基于示例1）
1. **添加新交通工具**
   - 实现 `ElectricCar`（电动汽车）类
   - 创建对应的 `ElectricCarCreator`
   - 添加充电相关的方法

2. **扩展功能**
   - 为交通工具添加速度属性
   - 实现 `get_max_speed()` 方法
   - 在创建者中添加速度比较功能

### 🔥 进阶练习（基于示例2）
1. **新设备类型**
   - 实现 `SmartWatch`（智能手表）类
   - 添加健康监测功能
   - 实现心率、步数等状态管理

2. **设备管理系统**
   - 实现设备配对功能
   - 添加设备同步机制
   - 创建设备群组管理

### 🚀 高级练习（基于示例3）
1. **新文档类型**
   - 实现 `PDFDocument` 类
   - 添加页面管理功能
   - 实现文档加密和权限控制

2. **文档协作系统**
   - 实现多用户编辑
   - 添加版本冲突解决
   - 创建文档分享和权限管理

3. **插件系统**
   - 设计文档插件接口
   - 实现语法高亮插件
   - 创建文档模板系统

## 运行示例

### 环境要求
- Python 3.7+
- 无需额外依赖包

### 运行方式
```bash
# 运行示例1
python example-1.py

# 运行示例2
python example-2.py

# 运行示例3
python example-3.py
```

### 预期输出
每个示例都会输出详细的执行过程和结果，展示工厂方法模式的工作原理。

## 适用场景
- 当一个类不知道它所必须创建的对象的类的时候
- 当一个类希望由它的子类来指定它所创建的对象的时候
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候
- 需要提供高度可配置的应用程序时
- 需要支持插件架构的系统

## 常见问题

### ❓ 设计相关
1. **Q: 工厂方法模式和简单工厂模式有什么区别？**
   - A: 工厂方法模式将对象的创建延迟到子类，而简单工厂模式在工厂类中直接创建对象。工厂方法模式更符合开闭原则，支持更好的扩展性。

2. **Q: 什么时候应该使用工厂方法模式？**
   - A: 当系统需要支持多种产品类型，且产品类型可能会扩展时；当需要将对象创建和使用分离时；当需要支持插件架构时。

3. **Q: 如何避免工厂方法模式带来的类爆炸问题？**
   - A: 可以通过使用参数化工厂方法、结合抽象工厂模式、或使用配置文件来减少类的数量。

### ❓ 实现相关
4. **Q: 为什么示例2中要维护产品实例？**
   - A: 为了保持产品的状态（如电池电量、开关机状态），如果每次都创建新实例，状态就会丢失。

5. **Q: 示例3中的元数据管理有什么作用？**
   - A: 元数据提供了文档的附加信息，如创建时间、版本号等，这在实际的文档管理系统中非常重要。

6. **Q: 如何选择合适的示例进行学习？**
   - A: 根据你的编程经验选择：初学者从示例1开始，有一定基础的从示例2开始，想要深入学习的直接学习示例3。

## 优点
- **解耦创建和使用**：将对象的创建和使用分离
- **支持开闭原则**：增加新的产品类时无需修改现有代码
- **隐藏创建细节**：提供了创建对象的接口，隐藏了对象创建的具体实现
- **符合单一职责原则**：每个创建者只负责创建一种产品
- **符合依赖倒置原则**：依赖抽象而不是具体实现

## 缺点
- **类数量增加**：每增加一个产品类，就需要增加一个具体工厂类
- **系统复杂度增加**：增加了系统的抽象性和理解难度
- **运行时开销**：相比直接实例化，工厂方法会有额外的方法调用开销

## 相关设计模式
- **抽象工厂模式**：工厂方法模式是抽象工厂模式的基础，抽象工厂可以看作是多个工厂方法的组合
- **建造者模式**：两者都用于创建对象，但建造者模式更关注对象的构建过程
- **单例模式**：工厂类通常可以实现为单例，避免重复创建工厂实例
- **原型模式**：可以结合使用，通过克隆来创建对象
- **策略模式**：工厂方法的选择可以使用策略模式来实现

## 最佳实践
1. **抽象方法设计**：将工厂方法声明为抽象方法，强制子类实现
2. **默认实现**：在抽象创建者类中提供默认的业务逻辑实现
3. **参数化工厂**：使用参数化工厂方法来减少子类数量
4. **依赖注入**：考虑使用依赖注入来管理工厂实例
5. **保持简单**：保持工厂方法的简单性，复杂的对象创建逻辑应该放在具体产品类中
6. **文档化**：为每个工厂和产品类提供清晰的文档说明
7. **测试覆盖**：确保每个工厂方法都有对应的单元测试

## 学习资源
1. **经典书籍**
   - 《设计模式：可复用面向对象软件的基础》- GoF
   - 《Head First设计模式》- Freeman & Robson

2. **在线资源**
   - [Refactoring Guru - 工厂方法模式](https://refactoring.guru/design-patterns/factory-method)
   - [Python设计模式指南](https://python-patterns.guide/)

3. **实践项目**
   - 尝试在实际项目中应用工厂方法模式
   - 参与开源项目，观察工厂方法模式的实际应用

## 总结
工厂方法模式是一个非常实用的创建型设计模式，通过本项目的三个递进式示例，你可以：

1. **从简单到复杂**：逐步理解工厂方法模式的应用
2. **理论结合实践**：通过实际代码理解抽象概念
3. **循序渐进**：根据自己的水平选择合适的学习起点
4. **动手实践**：通过练习题巩固所学知识

建议学习者不仅要理解代码的实现，更要思考为什么要这样设计，以及在什么场景下应用这种模式。只有真正理解了设计模式的思想，才能在实际开发中灵活运用。
