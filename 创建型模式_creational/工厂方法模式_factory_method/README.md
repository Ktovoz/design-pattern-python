# 工厂方法模式 (Factory Method Pattern)

## 简介
工厂方法模式是一种创建型设计模式，它提供了创建对象的接口，但允许子类决定实例化哪一个类。这种模式将类的实例化延迟到子类中进行，使得系统在不修改现有代码的情况下可以扩展。

## 模式结构
```
┌─────────────────┐     ┌─────────────────┐
│    Creator      │     │    Product      │
├─────────────────┤     ├─────────────────┤
│ +factoryMethod()│     │ +operation()    │
└────────┬────────┘     └────────┬────────┘
         │                       │
         │                       │
         ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│ ConcreteCreator │     │ ConcreteProduct │
├─────────────────┤     ├─────────────────┤
│ +factoryMethod()│     │ +operation()    │
└─────────────────┘     └─────────────────┘
```

## 核心角色
1. **抽象产品（Product）**
   - 定义产品的接口
   - 声明产品对象的基本操作

2. **具体产品（ConcreteProduct）**
   - 实现抽象产品接口
   - 定义具体的产品对象

3. **抽象创建者（Creator）**
   - 声明工厂方法
   - 可以包含产品对象的默认实现

4. **具体创建者（ConcreteCreator）**
   - 重写工厂方法
   - 返回具体产品实例

## 学习路径
1. **入门级（1-2小时）**
   - 阅读模式简介和核心角色说明
   - 学习示例1（交通工具工厂）
   - 理解基本的工厂方法模式结构

2. **进阶级（2-3小时）**
   - 学习示例2（电子产品工厂）
   - 理解状态管理和扩展方法
   - 尝试添加新的产品类型

3. **高级级（3-4小时）**
   - 学习示例3（文档处理系统）
   - 理解复杂数据结构和元数据管理
   - 尝试实现自己的文档类型

## 适用场景
- 当一个类不知道它所必须创建的对象的类的时候
- 当一个类希望由它的子类来指定它所创建的对象的时候
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候

## 实现示例

本项目提供了三个不同难度的工厂方法模式示例，从简单到复杂逐步展示该模式的应用：

### 示例1：交通工具工厂（基础难度）
- 文件：`example-1.py`
- 难度：⭐
- 特点：
  - 展示了工厂方法模式的基本结构
  - 简单的交通工具创建场景
  - 每个产品只有一个基本方法
  - 适合初学者理解工厂方法模式的核心概念
- 主要类：
  - 抽象产品：`Vehicle`
  - 具体产品：`Car`、`Bicycle`、`Motorcycle`
  - 抽象创建者：`VehicleCreator`
  - 具体创建者：`CarCreator`、`BicycleCreator`、`MotorcycleCreator`

### 示例2：电子产品工厂（中等难度）
- 文件：`example-2.py`
- 难度：⭐⭐
- 特点：
  - 增加了状态管理（电池电量和开关机状态）
  - 添加了更多的方法（开机、关机、检查电池）
  - 展示了更复杂的业务逻辑
  - 适合理解工厂方法模式在实际应用中的使用
- 主要类：
  - 抽象产品：`ElectronicProduct`
  - 具体产品：`Smartphone`、`Laptop`、`Tablet`
  - 抽象创建者：`ElectronicCreator`
  - 具体创建者：`SmartphoneCreator`、`LaptopCreator`、`TabletCreator`

### 示例3：文档处理系统（较高难度）
- 文件：`example-3.py`
- 难度：⭐⭐⭐
- 特点：
  - 引入了更复杂的数据结构（列表、字典）
  - 添加了元数据管理（创建时间、修改时间、版本）
  - 实现了更丰富的功能（内容添加、格式化、元数据查询）
  - 展示了工厂方法模式在文档处理系统中的应用
- 主要类：
  - 抽象产品：`Document`
  - 具体产品：`TextDocument`、`MarkdownDocument`、`HTMLDocument`
  - 抽象创建者：`DocumentCreator`
  - 具体创建者：`TextDocumentCreator`、`MarkdownDocumentCreator`、`HTMLDocumentCreator`

## 实践练习
1. **基础练习**
   - 在示例1中添加新的交通工具类型（如：电动车）
   - 实现新的交通工具创建者
   - 测试新添加的交通工具

2. **进阶练习**
   - 在示例2中添加新的电子产品类型（如：智能手表）
   - 实现新的电子产品创建者
   - 添加新的产品特性（如：健康监测）

3. **高级练习**
   - 在示例3中添加新的文档类型（如：PDF文档）
   - 实现新的文档创建者
   - 添加新的文档特性（如：加密功能）

## 常见问题
1. **Q: 工厂方法模式和简单工厂模式有什么区别？**
   - A: 工厂方法模式将对象的创建延迟到子类，而简单工厂模式在工厂类中直接创建对象。工厂方法模式更符合开闭原则。

2. **Q: 什么时候应该使用工厂方法模式？**
   - A: 当系统需要支持多种产品类型，且产品类型可能会扩展时，使用工厂方法模式是合适的。

3. **Q: 如何避免工厂方法模式带来的类爆炸问题？**
   - A: 可以通过使用参数化工厂方法或结合其他设计模式（如抽象工厂模式）来减少类的数量。

## 优点
- 将对象的创建和使用分离
- 支持开闭原则，增加新的产品类时无需修改现有代码
- 提供了创建对象的接口，隐藏了对象创建的具体实现
- 符合单一职责原则
- 符合依赖倒置原则

## 缺点
- 每增加一个产品类，就需要增加一个具体工厂类
- 类的数量增加，增加了系统的复杂度
- 增加了系统的抽象性和理解难度

## 相关设计模式
- **抽象工厂模式**：工厂方法模式是抽象工厂模式的基础
- **建造者模式**：两者都用于创建对象，但建造者模式更关注对象的构建过程
- **单例模式**：工厂类通常可以实现为单例
- **原型模式**：可以结合使用，通过克隆来创建对象

## 最佳实践
1. 将工厂方法声明为抽象方法，强制子类实现
2. 在抽象创建者类中提供默认实现
3. 使用参数化工厂方法来减少子类数量
4. 考虑使用依赖注入来管理工厂实例
5. 保持工厂方法的简单性，复杂的对象创建逻辑应该放在具体产品类中

## 参考资料
1. 《设计模式：可复用面向对象软件的基础》
2. 《Head First设计模式》
3. [Refactoring Guru - 工厂方法模式](https://refactoring.guru/design-patterns/factory-method)
