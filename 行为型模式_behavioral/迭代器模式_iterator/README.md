# 迭代器模式 (Iterator Pattern)

## 目录
1. [简介](#简介)
2. [模式动机](#模式动机)
3. [UML类图](#uml类图)
4. [核心组件](#核心组件)
5. [代码示例](#代码示例)
6. [实现要点](#实现要点)
7. [最佳实践](#最佳实践)
8. [常见问题](#常见问题)
9. [进阶主题](#进阶主题)
10. [测试策略](#测试策略)
11. [相关设计模式](#相关设计模式)
12. [实际应用场景](#实际应用场景)
13. [学习资源](#学习资源)

## 简介
迭代器模式是一种行为型设计模式，它提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。

### 适用场景
- 当需要访问一个聚合对象的元素，而不需要暴露其内部表示时
- 当需要为聚合对象提供多种遍历方式时
- 当需要为遍历不同的聚合结构提供一个统一的接口时

### 优点
- 提供了访问聚合元素的标准接口
- 支持多种遍历方式
- 支持对聚合对象的并发访问
- 简化了聚合类的接口
- 在同一个聚合上可以有多个遍历

### 缺点
- 迭代器的创建会增加内存开销
- 迭代器的创建和销毁需要消耗资源
- 对于简单的聚合对象，使用迭代器可能显得过于复杂

## 模式动机
1. **封装遍历算法**
   - 将遍历算法从集合类中分离出来
   - 使集合类更专注于数据存储

2. **统一访问接口**
   - 为不同的集合提供统一的遍历接口
   - 简化客户端代码

3. **支持多种遍历方式**
   - 可以在同一个集合上实现不同的遍历策略
   - 支持正向、反向、跳跃等遍历方式

## UML类图
```
+----------------+     +------------------+
|    Aggregate   |     |     Iterator     |
+----------------+     +------------------+
| +iterator()    |     | +hasNext()       |
+----------------+     | +next()          |
        ^              +------------------+
        |                      ^
        |                      |
+----------------+     +------------------+
|ConcreteAggregate|    |ConcreteIterator  |
+----------------+     +------------------+
| +iterator()    |     | -collection      |
+----------------+     | -position        |
                      | +hasNext()       |
                      | +next()          |
                      +------------------+
```

## 核心组件
1. **迭代器接口（Iterator）**
   - 定义访问和遍历元素的接口
   - 通常包含 `has_next()` 和 `next()` 方法

2. **具体迭代器（ConcreteIterator）**
   - 实现迭代器接口
   - 负责跟踪当前遍历位置

3. **聚合接口（Aggregate）**
   - 定义创建迭代器对象的接口
   - 通常包含 `iterator()` 方法

4. **具体聚合类（ConcreteAggregate）**
   - 实现聚合接口
   - 返回具体迭代器的实例

## 代码示例

### 示例1：书架迭代器（简单）⭐
```python
# 使用书架和书籍作为示例
# 展示了基本的迭代器模式实现
# 特点：
# - 简单的单向遍历
# - 基础的迭代器接口实现
# - 适合初学者理解迭代器模式
```

### 示例2：音乐播放列表（中等）⭐⭐
```python
# 使用音乐播放列表作为示例
# 展示了更复杂的迭代器实现
# 特点：
# - 支持双向遍历（前进和后退）
# - 包含更复杂的数据结构（Song类）
# - 展示了更多迭代器接口方法
```

### 示例3：文件系统（复杂）⭐⭐⭐
```python
# 使用文件系统作为示例
# 展示了高级迭代器模式应用
# 特点：
# - 实现递归遍历
# - 支持文件过滤功能
# - 包含错误处理
# - 支持迭代器重置
# - 使用类型提示和现代Python特性
```

## 实现要点
1. **接口设计**
   - 迭代器接口应该足够简单，只包含必要的方法
   - 考虑是否需要支持双向遍历
   - 是否需要支持删除操作

2. **并发考虑**
   - 在遍历过程中修改集合可能导致问题
   - 考虑是否需要支持并发遍历

3. **性能优化**
   - 避免在迭代器中存储大量数据
   - 考虑使用惰性加载（Lazy Loading）

## 最佳实践
1. 保持迭代器接口简单
2. 考虑遍历过程中的异常处理
3. 注意迭代器的生命周期管理
4. 合理使用泛型或类型提示
5. 考虑是否需要支持并发遍历

## 常见问题

### 1. 遍历过程中的修改问题
```python
# 问题：在遍历过程中修改集合可能导致异常
# 解决方案：使用快照或并发集合
class SafeIterator:
    def __init__(self, collection):
        self.snapshot = list(collection)  # 创建快照
        self.index = 0
```

### 2. 内存占用问题
```python
# 问题：迭代器可能占用大量内存
# 解决方案：使用生成器实现惰性加载
def lazy_iterator(collection):
    for item in collection:
        yield item  # 惰性加载
```

### 3. 并发访问问题
```python
# 问题：多线程访问可能导致数据不一致
# 解决方案：使用线程安全的迭代器
from threading import Lock

class ThreadSafeIterator:
    def __init__(self, collection):
        self.collection = collection
        self.lock = Lock()
        self.index = 0
```

## 进阶主题

### 1. 组合迭代器
- 用于遍历树形结构
- 支持深度优先和广度优先遍历
- 可以组合多个迭代器

### 2. 过滤迭代器
- 在遍历过程中过滤元素
- 支持链式过滤操作
- 可以组合多个过滤条件

### 3. 并行迭代器
- 支持多线程遍历
- 实现数据分片处理
- 提高遍历效率

## 测试策略
1. **单元测试**
   - 测试迭代器的基本功能
   - 验证遍历顺序
   - 检查边界条件

2. **集成测试**
   - 测试迭代器与集合的交互
   - 验证并发访问
   - 检查内存使用

3. **性能测试**
   - 测试大规模数据遍历
   - 验证内存占用
   - 检查遍历效率

## 相关设计模式
- **组合模式**：迭代器常用于遍历组合结构
- **工厂方法模式**：用于创建适当的迭代器
- **备忘录模式**：可以用于保存迭代器的状态
- **访问者模式**：可以配合迭代器使用，对集合中的元素执行操作

## 实际应用场景
1. **集合框架**
   - Java的Collection框架
   - Python的迭代器协议

2. **数据库查询**
   - 结果集的遍历
   - 分页查询

3. **文件系统**
   - 目录遍历
   - 文件搜索

4. **UI组件**
   - 菜单项遍历
   - 树形结构遍历

## 学习资源

### 推荐书籍
1. 《设计模式：可复用面向对象软件的基础》
2. 《Head First设计模式》
3. 《Python设计模式》
4. 《Java设计模式》

### 在线资源
1. [Python迭代器文档](https://docs.python.org/3/library/stdtypes.html#iterator-types)
2. [Java迭代器接口](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)
3. [设计模式教程](https://refactoring.guru/design-patterns/iterator)
